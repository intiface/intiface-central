// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../api/enums.dart';
import '../frb_generated.dart';
import '../lib.dart';
import 'buttplug_server_device_config/device_config_manager.dart';
import 'buttplug_server_device_config/server_device_feature.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:uuid/uuid.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`, `fmt`

Future<DeviceConfigurationManagerBuilder> loadProtocolConfigs({
  String? mainConfigStr,
  String? userConfigStr,
  required bool skipVersionCheck,
}) => RustLib.instance.api.buttplugServerDeviceConfigLoadProtocolConfigs(
  mainConfigStr: mainConfigStr,
  userConfigStr: userConfigStr,
  skipVersionCheck: skipVersionCheck,
);

Future<String> saveUserConfig({required DeviceConfigurationManager dcm}) =>
    RustLib.instance.api.buttplugServerDeviceConfigSaveUserConfig(dcm: dcm);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BaseDeviceIdentifier>>
abstract class BaseDeviceIdentifier implements RustOpaqueInterface {
  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<BaseDeviceIdentifier> newInstance({
    required String protocol,
    String? attributesIdentifier,
  }) => RustLib.instance.api.buttplugServerDeviceConfigBaseDeviceIdentifierNew(
    protocol: protocol,
    attributesIdentifier: attributesIdentifier,
  );

  static Future<BaseDeviceIdentifier> newDefault({required String protocol}) =>
      RustLib.instance.api
          .buttplugServerDeviceConfigBaseDeviceIdentifierNewDefault(
            protocol: protocol,
          );

  static Future<BaseDeviceIdentifier> newWithIdentifier({
    required String protocol,
    required String attributesIdentifier,
  }) => RustLib.instance.api
      .buttplugServerDeviceConfigBaseDeviceIdentifierNewWithIdentifier(
        protocol: protocol,
        attributesIdentifier: attributesIdentifier,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BluetoothLEManufacturerData>>
abstract class BluetoothLeManufacturerData implements RustOpaqueInterface {
  Future<void> company();

  Future<void> data();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<BluetoothLeManufacturerData> newInstance({
    required int company,
    Uint8List? data,
  }) => RustLib.instance.api
      .buttplugServerDeviceConfigBluetoothLeManufacturerDataNew(
        company: company,
        data: data,
      );

  Future<void> setCompany({required int val});

  Future<void> setData({Uint8List? val});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BluetoothLESpecifier>>
abstract class BluetoothLeSpecifier implements RustOpaqueInterface {
  /// Set of expected advertised services for this device.
  Future<void> advertisedServices();

  /// Array of possible manufacturer data values.
  Future<void> manufacturerData();

  /// Merge with another BLE specifier, used when loading user configs that extend a protocol
  /// definition.
  Future<void> merge({required BluetoothLeSpecifier other});

  /// Set of expected advertised names for this device.
  Future<void> names();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<BluetoothLeSpecifier> newInstance({
    required Set<String> names,
    required List<BluetoothLeManufacturerData> manufacturerData,
    required Set<UuidValue> advertisedServices,
    required Map<UuidValue, Map<Endpoint, UuidValue>> services,
  }) => RustLib.instance.api.buttplugServerDeviceConfigBluetoothLeSpecifierNew(
    names: names,
    manufacturerData: manufacturerData,
    advertisedServices: advertisedServices,
    services: services,
  );

  /// Creates a specifier from a BLE device advertisement.
  static Future<BluetoothLeSpecifier> newFromDevice({
    required String name,
    required Map<int, Uint8List> manufacturerData,
    required List<UuidValue> advertisedServices,
  }) => RustLib.instance.api
      .buttplugServerDeviceConfigBluetoothLeSpecifierNewFromDevice(
        name: name,
        manufacturerData: manufacturerData,
        advertisedServices: advertisedServices,
      );

  /// Services we expect the device may have. More services may be listed in a specifier than any
  /// one device may have, but we expect at least one to be matched by a device in order to consider
  /// the device part of the protocol that has this specifier.
  Future<void> services();

  /// Set of expected advertised services for this device.
  Future<void> setAdvertisedServices({required Set<UuidValue> val});

  /// Array of possible manufacturer data values.
  Future<void> setManufacturerData({
    required List<BluetoothLeManufacturerData> val,
  });

  /// Set of expected advertised names for this device.
  Future<void> setNames({required Set<String> val});

  /// Services we expect the device may have. More services may be listed in a specifier than any
  /// one device may have, but we expect at least one to be matched by a device in order to consider
  /// the device part of the protocol that has this specifier.
  Future<void> setServices({
    required Map<UuidValue, Map<Endpoint, UuidValue>> val,
  });
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ButtplugDeviceConfigError>>
abstract class ButtplugDeviceConfigError implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ButtplugError>>
abstract class ButtplugError implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DeviceConfigurationManager>>
abstract class DeviceConfigurationManager implements RustOpaqueInterface {
  Future<void> addUserCommunicationSpecifier({
    required String protocol,
    required ProtocolCommunicationSpecifier specifier,
  });

  Future<void> addUserDeviceDefinition({
    required UserDeviceIdentifier identifier,
    required ServerDeviceDefinition definition,
  });

  Future<bool> addressAllowed({required String address});

  /// Communication specifiers from the base device config, mapped from protocol name to vector of
  /// specifiers. Should not change/update during a session.
  Future<void> baseCommunicationSpecifiers();

  static Future<DeviceConfigurationManager> default_() => RustLib.instance.api
      .buttplugServerDeviceConfigDeviceConfigurationManagerDefault();

  Future<ServerDeviceDefinition?> deviceDefinition({
    required UserDeviceIdentifier identifier,
  });

  Future<void> removeUserCommunicationSpecifier({
    required String protocol,
    required ProtocolCommunicationSpecifier specifier,
  });

  Future<void> removeUserDeviceDefinition({
    required UserDeviceIdentifier identifier,
  });

  /// Communication specifiers provided by the user, mapped from protocol name to vector of
  /// specifiers. Loaded at session start, may change over life of session.
  Future<void> userCommunicationSpecifiers();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DeviceConfigurationManagerBuilder>>
abstract class DeviceConfigurationManagerBuilder
    implements RustOpaqueInterface {
  Future<void> baseDeviceDefinition({
    required BaseDeviceIdentifier identifier,
    required ServerDeviceDefinition features,
  });

  Future<void> communicationSpecifier({
    required String protocolName,
    required List<ProtocolCommunicationSpecifier> specifier,
  });

  static Future<DeviceConfigurationManagerBuilder> default_() => RustLib
      .instance
      .api
      .buttplugServerDeviceConfigDeviceConfigurationManagerBuilderDefault();

  Future<DeviceConfigurationManager> finish();

  Future<void> userCommunicationSpecifier({
    required String protocolName,
    required List<ProtocolCommunicationSpecifier> specifier,
  });

  Future<void> userDeviceDefinition({
    required UserDeviceIdentifier identifier,
    required ServerDeviceDefinition deviceDefinition,
  });
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LovenseConnectServiceSpecifier>>
abstract class LovenseConnectServiceSpecifier implements RustOpaqueInterface {
  static Future<LovenseConnectServiceSpecifier> default_() => RustLib
      .instance
      .api
      .buttplugServerDeviceConfigLovenseConnectServiceSpecifierDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtocolCommunicationSpecifier>>
abstract class ProtocolCommunicationSpecifier implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RangeWithLimit>>
abstract class RangeWithLimit implements RustOpaqueInterface {
  Future<void> base();

  Future<void> internalBase();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<RangeWithLimit> newInstance({
    required RangeInclusiveI32 base,
  }) => RustLib.instance.api.buttplugServerDeviceConfigRangeWithLimitNew(
    base: base,
  );

  Future<int> stepCount();

  Future<RangeInclusiveI32> stepLimit();

  static Future<RangeWithLimit> tryNew({
    required RangeInclusiveI32 base,
    RangeInclusiveU32? user,
  }) => RustLib.instance.api.buttplugServerDeviceConfigRangeWithLimitTryNew(
    base: base,
    user: user,
  );

  Future<void> user();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SerialSpecifier>>
abstract class SerialSpecifier implements RustOpaqueInterface {
  Future<void> baudRate();

  Future<void> dataBits();

  static Future<SerialSpecifier> default_() =>
      RustLib.instance.api.buttplugServerDeviceConfigSerialSpecifierDefault();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<SerialSpecifier> newInstance({
    required String port,
    required int baudRate,
    required int dataBits,
    required int stopBits,
    required String parity,
  }) => RustLib.instance.api.buttplugServerDeviceConfigSerialSpecifierNew(
    port: port,
    baudRate: baudRate,
    dataBits: dataBits,
    stopBits: stopBits,
    parity: parity,
  );

  /// Given a serial port name (the only identifier we have for this type of device), create a
  /// specifier instance.
  static Future<SerialSpecifier> newFromName({required String port}) => RustLib
      .instance
      .api
      .buttplugServerDeviceConfigSerialSpecifierNewFromName(port: port);

  Future<void> parity();

  Future<void> port();

  Future<void> setBaudRate({required int val});

  Future<void> setDataBits({required int val});

  Future<void> setParity({required String val});

  Future<void> setPort({required String val});

  Future<void> setStopBits({required int val});

  Future<void> stopBits();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ServerDeviceDefinition>>
abstract class ServerDeviceDefinition implements RustOpaqueInterface {
  Future<bool> allow();

  Future<UuidValue?> baseId();

  Future<bool> deny();

  Future<void> displayName();

  Future<void> features();

  Future<UuidValue> id();

  Future<int> index();

  Future<int?> messageGapMs();

  /// Given name of the device this instance represents.
  Future<void> name();

  Future<void> protocolVariant();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ServerDeviceDefinitionBuilder>>
abstract class ServerDeviceDefinitionBuilder implements RustOpaqueInterface {
  Future<void> addFeature({required ServerDeviceFeature feature});

  Future<void> allow();

  Future<void> baseId({required UuidValue id});

  Future<void> deny();

  Future<void> displayName({required String name});

  Future<ServerDeviceDefinition> finish();

  static Future<ServerDeviceDefinitionBuilder> fromBase({
    required ServerDeviceDefinition value,
    required UuidValue id,
  }) => RustLib.instance.api
      .buttplugServerDeviceConfigServerDeviceDefinitionBuilderFromBase(
        value: value,
        id: id,
      );

  Future<void> id({required UuidValue id});

  Future<void> index({required int index});

  Future<void> messageGapMs({required int gap});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<ServerDeviceDefinitionBuilder> newInstance({
    required String name,
    required UuidValue id,
  }) => RustLib.instance.api
      .buttplugServerDeviceConfigServerDeviceDefinitionBuilderNew(
        name: name,
        id: id,
      );

  Future<void> protocolVariant({required String variant});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ServerDeviceFeature>>
abstract class ServerDeviceFeature implements RustOpaqueInterface {
  Future<int?> altProtocolIndex();

  Future<DeviceFeature> asDeviceFeature({required int index});

  Future<ServerDeviceFeature> asNewUserFeature();

  Future<UuidValue?> baseId();

  Future<void> description();

  Future<UuidValue> id();

  Future<void> input();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<ServerDeviceFeature> newInstance({
    required String description,
    required UuidValue id,
    UuidValue? baseId,
    int? altProtocolIndex,
    ServerDeviceFeatureOutput? output,
    ServerDeviceFeatureInput? input,
  }) => RustLib.instance.api.buttplugServerDeviceConfigServerDeviceFeatureNew(
    description: description,
    id: id,
    baseId: baseId,
    altProtocolIndex: altProtocolIndex,
    output: output,
    input: input,
  );

  Future<void> output();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ServerDeviceFeatureInput>>
abstract class ServerDeviceFeatureInput implements RustOpaqueInterface {
  Future<void> battery();

  Future<void> button();

  Future<bool> contains({required InputType inputType});

  static Future<ServerDeviceFeatureInput> default_() => RustLib.instance.api
      .buttplugServerDeviceConfigServerDeviceFeatureInputDefault();

  Future<void> pressure();

  Future<void> rssi();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ServerDeviceFeatureInputProperties>>
abstract class ServerDeviceFeatureInputProperties
    implements RustOpaqueInterface {
  Future<void> inputCommands();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<ServerDeviceFeatureInputProperties> newInstance({
    required List<RangeInclusiveI32> valueRange,
    required Set<InputCommandType> sensorCommands,
  }) => RustLib.instance.api
      .buttplugServerDeviceConfigServerDeviceFeatureInputPropertiesNew(
        valueRange: valueRange,
        sensorCommands: sensorCommands,
      );

  Future<void> valueRange();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ServerDeviceFeatureOutput>>
abstract class ServerDeviceFeatureOutput implements RustOpaqueInterface {
  Future<int> calculateFromFloat({
    required OutputType outputType,
    required double value,
  });

  Future<int> calculateFromValue({
    required OutputType outputType,
    required int value,
  });

  Future<void> constrict();

  Future<bool> contains({required OutputType outputType});

  static Future<ServerDeviceFeatureOutput> default_() => RustLib.instance.api
      .buttplugServerDeviceConfigServerDeviceFeatureOutputDefault();

  Future<void> heater();

  Future<void> led();

  Future<void> oscillate();

  Future<List<OutputType>> outputTypes();

  Future<void> position();

  Future<void> positionWithDuration();

  Future<void> rotate();

  Future<void> rotateWithDirection();

  Future<void> spray();

  Future<void> vibrate();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ServerDeviceFeatureOutputPositionProperties>>
abstract class ServerDeviceFeatureOutputPositionProperties
    implements RustOpaqueInterface {
  Future<int> calculateScaledFloat({required double value});

  Future<int> calculateScaledValue({required int value});

  Future<bool> disabled();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<ServerDeviceFeatureOutputPositionProperties> newInstance({
    required RangeWithLimit position,
    required bool disabled,
    required bool reversePosition,
  }) => RustLib.instance.api
      .buttplugServerDeviceConfigServerDeviceFeatureOutputPositionPropertiesNew(
        position: position,
        disabled: disabled,
        reversePosition: reversePosition,
      );

  Future<void> position();

  Future<bool> reversePosition();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ServerDeviceFeatureOutputPositionWithDurationProperties>>
abstract class ServerDeviceFeatureOutputPositionWithDurationProperties
    implements RustOpaqueInterface {
  Future<int> calculateScaledFloat({required double value});

  Future<int> calculateScaledValue({required int value});

  Future<bool> disabled();

  Future<void> duration();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<ServerDeviceFeatureOutputPositionWithDurationProperties>
  newInstance({
    required RangeWithLimit position,
    required RangeWithLimit duration,
    required bool disabled,
    required bool reversePosition,
  }) => RustLib.instance.api
      .buttplugServerDeviceConfigServerDeviceFeatureOutputPositionWithDurationPropertiesNew(
        position: position,
        duration: duration,
        disabled: disabled,
        reversePosition: reversePosition,
      );

  Future<void> position();

  Future<bool> reversePosition();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ServerDeviceFeatureOutputValueProperties>>
abstract class ServerDeviceFeatureOutputValueProperties
    implements RustOpaqueInterface {
  Future<int> calculateScaledFloat({required double value});

  Future<int> calculateScaledValue({required int value});

  Future<bool> disabled();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<ServerDeviceFeatureOutputValueProperties> newInstance({
    required RangeWithLimit value,
    required bool disabled,
  }) => RustLib.instance.api
      .buttplugServerDeviceConfigServerDeviceFeatureOutputValuePropertiesNew(
        value: value,
        disabled: disabled,
      );

  Future<void> value();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserDeviceIdentifier>>
abstract class UserDeviceIdentifier implements RustOpaqueInterface {
  /// Address, as possibly serialized by whatever the managing library for the Device Communication Manager is.
  Future<void> address();

  /// Internal identifier for the protocol used
  Future<void> identifier();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new instance
  static Future<UserDeviceIdentifier> newInstance({
    required String address,
    required String protocol,
    String? identifier,
  }) => RustLib.instance.api.buttplugServerDeviceConfigUserDeviceIdentifierNew(
    address: address,
    protocol: protocol,
    identifier: identifier,
  );

  /// Name of the protocol used
  Future<void> protocol();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VIDPIDPair>>
abstract class VidpidPair implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VIDPIDSpecifier>>
abstract class VidpidSpecifier implements RustOpaqueInterface {
  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<VidpidSpecifier> newInstance({
    required int vendorId,
    required int productId,
  }) => RustLib.instance.api.buttplugServerDeviceConfigVidpidSpecifierNew(
    vendorId: vendorId,
    productId: productId,
  );

  Future<void> pairs();

  Future<void> setPairs({required List<VidpidPair> val});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WebsocketSpecifier>>
abstract class WebsocketSpecifier implements RustOpaqueInterface {
  static Future<WebsocketSpecifier> default_() => RustLib.instance.api
      .buttplugServerDeviceConfigWebsocketSpecifierDefault();

  Future<void> name();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<WebsocketSpecifier> newInstance({required String name}) =>
      RustLib.instance.api.buttplugServerDeviceConfigWebsocketSpecifierNew(
        name: name,
      );

  Future<void> setName({required String val});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<XInputSpecifier>>
abstract class XInputSpecifier implements RustOpaqueInterface {
  static Future<XInputSpecifier> default_() =>
      RustLib.instance.api.buttplugServerDeviceConfigXInputSpecifierDefault();
}

/// Endpoint names for device communication.
///
/// Endpoints denote different contextual communication targets on a device. For instance, for a
/// device that uses UART style communication (serial, a lot of Bluetooth LE devices, etc...) most
/// devices will just have a Tx and Rx endpoint. However, on other devices that can have varying
/// numbers of endpoints and configurations (USB, Bluetooth LE, etc...) we add some names with more
/// context. These names are used in [Device Configuration](crate::server::device::configuration)
/// and the [Device Configuration File](crate::util::device_configuration), and are expected to
/// de/serialize to lowercase versions of their names.
enum Endpoint {
  /// Expect to take commands, when multiple receive endpoints may be available
  command,

  /// Firmware updates (Buttplug does not update firmware, but some firmware endpoints are used for
  /// mode setting)
  firmware,

  /// Common receive endpoint name
  rx,

  /// Receive endpoint for accelerometer data
  rxAccel,

  /// Receive endpoint for battery levels (usually expected to be BLE standard profile)
  rxBleBattery,

  /// Receive endpoint for BLE model (usually expected to be BLE standard profile)
  rxBleModel,

  /// Receive endpoint for pressure sensors
  rxPressure,

  /// Receive endpoint for touch sensors
  rxTouch,

  /// Common transmit endpoint name
  tx,

  /// Transmit endpoint for hardware mode setting.
  txMode,

  /// Transmit endpoint for shock setting (unused)
  txShock,

  /// Transmit endpoint for vibration setting
  txVibrate,

  /// Transmit endpoint for vendor (proprietary) control
  txVendorControl,

  /// Transmit endpoint for whitelist updating
  whitelist,

  /// Generic endpoint (available for user configurations)
  generic0,

  /// Generic endpoint (available for user configurations)
  generic1,

  /// Generic endpoint (available for user configurations)
  generic2,

  /// Generic endpoint (available for user configurations)
  generic3,

  /// Generic endpoint (available for user configurations)
  generic4,

  /// Generic endpoint (available for user configurations)
  generic5,

  /// Generic endpoint (available for user configurations)
  generic6,

  /// Generic endpoint (available for user configurations)
  generic7,

  /// Generic endpoint (available for user configurations)
  generic8,

  /// Generic endpoint (available for user configurations)
  generic9,

  /// Generic endpoint (available for user configurations)
  generic10,

  /// Generic endpoint (available for user configurations)
  generic11,

  /// Generic endpoint (available for user configurations)
  generic12,

  /// Generic endpoint (available for user configurations)
  generic13,

  /// Generic endpoint (available for user configurations)
  generic14,

  /// Generic endpoint (available for user configurations)
  generic15,

  /// Generic endpoint (available for user configurations)
  generic16,

  /// Generic endpoint (available for user configurations)
  generic17,

  /// Generic endpoint (available for user configurations)
  generic18,

  /// Generic endpoint (available for user configurations)
  generic19,

  /// Generic endpoint (available for user configurations)
  generic20,

  /// Generic endpoint (available for user configurations)
  generic21,

  /// Generic endpoint (available for user configurations)
  generic22,

  /// Generic endpoint (available for user configurations)
  generic23,

  /// Generic endpoint (available for user configurations)
  generic24,

  /// Generic endpoint (available for user configurations)
  generic25,

  /// Generic endpoint (available for user configurations)
  generic26,

  /// Generic endpoint (available for user configurations)
  generic27,

  /// Generic endpoint (available for user configurations)
  generic28,

  /// Generic endpoint (available for user configurations)
  generic29,

  /// Generic endpoint (available for user configurations)
  generic30,

  /// Generic endpoint (available for user configurations)
  generic31,
}
