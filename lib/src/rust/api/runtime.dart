// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `BACKDOOR_INCOMING_BROADCASTER`, `ENGINE_BROADCASTER`, `ENGINE_FRONTEND`, `ENGINE_NOTIFIER`, `ENGINE_SHUTDOWN`, `RUNTIME`, `RUN_STATUS`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `deref`, `deref`, `deref`, `deref`, `deref`, `deref`, `deref`, `initialize`, `initialize`, `initialize`, `initialize`, `initialize`, `initialize`, `initialize`

Future<bool> rustRuntimeStarted() =>
    RustLib.instance.api.crateApiRuntimeRustRuntimeStarted();

/// Check if the engine is currently shutting down.
/// Used by other modules to prevent sending messages to closed streams.
Future<bool> isEngineShutdown() =>
    RustLib.instance.api.crateApiRuntimeIsEngineShutdown();

Stream<String> runEngine({required EngineOptionsExternal args}) =>
    RustLib.instance.api.crateApiRuntimeRunEngine(args: args);

Future<void> sendRuntimeMsg({required String msgJson}) =>
    RustLib.instance.api.crateApiRuntimeSendRuntimeMsg(msgJson: msgJson);

Future<void> stopEngine() => RustLib.instance.api.crateApiRuntimeStopEngine();

Future<void> sendBackendServerMessage({required String msg}) =>
    RustLib.instance.api.crateApiRuntimeSendBackendServerMessage(msg: msg);

class EngineOptionsExternal {
  final String? deviceConfigJson;
  final String? userDeviceConfigJson;
  final String? userDeviceConfigPath;
  final String serverName;
  final bool websocketUseAllInterfaces;
  final int? websocketPort;
  final int? frontendWebsocketPort;
  final bool frontendInProcessChannel;
  final int maxPingTime;
  final bool useBluetoothLe;
  final bool useSerialPort;
  final bool useHid;
  final bool useLovenseDongleSerial;
  final bool useLovenseDongleHid;
  final bool useXinput;
  final bool useLovenseConnect;
  final bool useDeviceWebsocketServer;
  final int? deviceWebsocketServerPort;
  final bool crashMainThread;
  final bool crashTaskThread;
  final String? websocketClientAddress;
  final bool broadcastServerMdns;
  final String? mdnsSuffix;
  final bool repeaterMode;
  final int? repeaterLocalPort;
  final String? repeaterRemoteAddress;
  final int? restApiPort;

  const EngineOptionsExternal({
    this.deviceConfigJson,
    this.userDeviceConfigJson,
    this.userDeviceConfigPath,
    required this.serverName,
    required this.websocketUseAllInterfaces,
    this.websocketPort,
    this.frontendWebsocketPort,
    required this.frontendInProcessChannel,
    required this.maxPingTime,
    required this.useBluetoothLe,
    required this.useSerialPort,
    required this.useHid,
    required this.useLovenseDongleSerial,
    required this.useLovenseDongleHid,
    required this.useXinput,
    required this.useLovenseConnect,
    required this.useDeviceWebsocketServer,
    this.deviceWebsocketServerPort,
    required this.crashMainThread,
    required this.crashTaskThread,
    this.websocketClientAddress,
    required this.broadcastServerMdns,
    this.mdnsSuffix,
    required this.repeaterMode,
    this.repeaterLocalPort,
    this.repeaterRemoteAddress,
    this.restApiPort,
  });

  @override
  int get hashCode =>
      deviceConfigJson.hashCode ^
      userDeviceConfigJson.hashCode ^
      userDeviceConfigPath.hashCode ^
      serverName.hashCode ^
      websocketUseAllInterfaces.hashCode ^
      websocketPort.hashCode ^
      frontendWebsocketPort.hashCode ^
      frontendInProcessChannel.hashCode ^
      maxPingTime.hashCode ^
      useBluetoothLe.hashCode ^
      useSerialPort.hashCode ^
      useHid.hashCode ^
      useLovenseDongleSerial.hashCode ^
      useLovenseDongleHid.hashCode ^
      useXinput.hashCode ^
      useLovenseConnect.hashCode ^
      useDeviceWebsocketServer.hashCode ^
      deviceWebsocketServerPort.hashCode ^
      crashMainThread.hashCode ^
      crashTaskThread.hashCode ^
      websocketClientAddress.hashCode ^
      broadcastServerMdns.hashCode ^
      mdnsSuffix.hashCode ^
      repeaterMode.hashCode ^
      repeaterLocalPort.hashCode ^
      repeaterRemoteAddress.hashCode ^
      restApiPort.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EngineOptionsExternal &&
          runtimeType == other.runtimeType &&
          deviceConfigJson == other.deviceConfigJson &&
          userDeviceConfigJson == other.userDeviceConfigJson &&
          userDeviceConfigPath == other.userDeviceConfigPath &&
          serverName == other.serverName &&
          websocketUseAllInterfaces == other.websocketUseAllInterfaces &&
          websocketPort == other.websocketPort &&
          frontendWebsocketPort == other.frontendWebsocketPort &&
          frontendInProcessChannel == other.frontendInProcessChannel &&
          maxPingTime == other.maxPingTime &&
          useBluetoothLe == other.useBluetoothLe &&
          useSerialPort == other.useSerialPort &&
          useHid == other.useHid &&
          useLovenseDongleSerial == other.useLovenseDongleSerial &&
          useLovenseDongleHid == other.useLovenseDongleHid &&
          useXinput == other.useXinput &&
          useLovenseConnect == other.useLovenseConnect &&
          useDeviceWebsocketServer == other.useDeviceWebsocketServer &&
          deviceWebsocketServerPort == other.deviceWebsocketServerPort &&
          crashMainThread == other.crashMainThread &&
          crashTaskThread == other.crashTaskThread &&
          websocketClientAddress == other.websocketClientAddress &&
          broadcastServerMdns == other.broadcastServerMdns &&
          mdnsSuffix == other.mdnsSuffix &&
          repeaterMode == other.repeaterMode &&
          repeaterLocalPort == other.repeaterLocalPort &&
          repeaterRemoteAddress == other.repeaterRemoteAddress &&
          restApiPort == other.restApiPort;
}
